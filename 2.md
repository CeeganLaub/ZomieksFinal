
### 0.1 Escrow semantics (Option A)
- Buyer pays **platform** (single merchant account).
- Platform records **gross / fee / net** from gateway (PayFast ITN/Ozow callback).
- Platform holds funds as **EscrowHold** ledger entry.
- On completion/milestone release, platform creates **SellerPayout** ledger entry.
- Actual seller payouts occur via **batch payout run** (daily/weekly) using bank EFT (external), not PayFast split.

### 0.2 Fee semantics (profit-safe)
Replace single `buyerFee` with:
- `buyerProcessingFee` (covers gateway costs; minimum applies)
- `buyerPlatformFee` (actual marketplace buyer fee; can remain 3% if desired)
- `sellerPlatformFee` (seller fee; can remain 8% but recommended tiering/minimum)

**PlatformRevenue** = `buyerPlatformFee + sellerPlatformFee`  
**GatewayFee** is not revenue; it’s a cost.

### 0.3 Integrity checks
- ITN/callback must verify:
  - `amount_gross == expectedGross` (exact match, currency match)
  - signature validation (PayFast ITN)
  - order status transitions are idempotent

---

## 1) Fix Schema ↔ Webhook Mismatch (Critical Bug)

### 1.1 Current issue
`apps/api/src/routes/webhook.routes.ts` creates Transaction fields like:
- `type`, `grossAmount`, `gatewayFee`, `netAmount`, `gatewayResponse`
…but `apps/api/prisma/schema.prisma` Transaction model does not contain these fields (runtime error).

### 1.2 Required action
**Make Transaction model escrow/gateway compatible.** Update Prisma schema + migrations.

#### 1.2.1 Prisma model changes (suggested)
Update `Transaction` to include:

- `type` (enum: `PAYMENT|REFUND|PAYOUT|ADJUSTMENT`)
- `gateway` (enum: `PAYFAST|OZOW|MANUAL`)
- `gatewayRef` (string, unique per gateway payment/refund)
- `grossAmount` (decimal)
- `gatewayFee` (decimal, nullable if not provided)
- `netAmount` (decimal, nullable)
- `currency` (string, default "ZAR")
- `rawPayload` (json)
- `status` (enum: `PENDING|SUCCESS|FAILED`)
- `orderId` (nullable for payouts/adjustments)

Also store fee snapshot in Transaction for audit:
- `buyerProcessingFee`
- `buyerPlatformFee`
- `sellerPlatformFee`
- `platformRevenue`

> Keep existing fields only if needed; otherwise migrate away from:
> `amount`, `buyerFee`, `sellerFee`, `totalAmount` in Transaction if they conflict with new approach.

#### 1.2.2 Migrations
- Create migration and update all Prisma create calls to match new schema.

#### 1.2.3 Update webhook route code to match schema
- Ensure `prisma.transaction.create()` fields align exactly.

---

## 2) Implement Gateway-Aware Fee Engine

### 2.1 Replace `calculateOrderFees(baseAmount)`
Current: `apps/api/src/services/payment.service.ts` (or wherever `calculateOrderFees` is defined)

Create a new module:

`apps/api/src/services/fee-engine.ts`

Export:

```ts
type Gateway = "PAYFAST" | "OZOW";
type Method = "CARD" | "EFT" | "UNKNOWN";

interface FeePolicy {
  buyerPlatformPct: number;       // e.g. 0.03
  buyerPlatformMin: number;       // e.g. 10
  buyerProcessingMin: number;     // e.g. 10 or 15
  sellerTiers: Array<{ upTo?: number; pct: number; min: number }>; // tiering
  bufferPct: number;             // e.g. 0.002 (0.2%) safety buffer
  bufferFixed: number;           // e.g. 1.0 (R1) safety buffer
}

interface FeeCalcInput {
  baseAmount: number;     // P
  currency: "ZAR";
  gateway: Gateway;
  method: Method;
  policy: FeePolicy;
}

interface FeeCalcOutput {
  baseAmount: number;
  buyerPlatformFee: number;
  buyerProcessingFee: number;
  sellerPlatformFee: number;
  platformRevenue: number;      // buyerPlatformFee + sellerPlatformFee
  grossAmount: number;          // baseAmount + buyerPlatformFee + buyerProcessingFee
  sellerPayoutTarget: number;   // baseAmount - sellerPlatformFee (NOT net; payout happens later)
  estimatedGatewayFee: number;  // estimate on gross
  estimatedNetToPlatform: number; // gross - estimatedGatewayFee
}
2.2 Gateway fee estimation rules (PayFast)
Use PayFast public fees (ex VAT) and apply VAT to fees for estimate:

Card: 3.2% + R2 (ex VAT)

Instant EFT: 2% (min R2) (ex VAT)

Add policy buffer (pct + fixed) to reduce under-collection risk.

Do not hardcode PayFast fees in multiple places. Centralize in fee engine.

2.3 Minimum fees
Enforce:

buyerProcessingFee >= buyerProcessingMin

buyerPlatformFee >= buyerPlatformMin (optional)

sellerPlatformFee >= tier.min

2.4 Seller tiering (recommended)
Example default tiers:

Up to R500: 12% min R15

Up to R2000: 10% min R20

Above: 8% min R30

Make tiers configurable (db later); for now keep in config.

3) Order Pricing Must Occur After Payment Method Selection
3.1 Current problem
Order total is fixed before buyer chooses:

PayFast card vs EFT vs Ozow
But processing costs differ.

3.2 Required change (choose one approach)
Option A (recommended)
Step 1: Client selects gateway/method
Step 2: API returns quote breakdown (fees + gross total)
Step 3: Client confirms quote → API creates order with final totals
Step 4: Redirect to PayFast/Ozow with exact gross amount

Implement endpoints:

POST /orders/quote

input: { baseAmount, gateway, method }

output: FeeCalcOutput

POST /orders

input includes: { quoteId or quoteHash, baseAmount, gateway, method, ... }

server recomputes fees and persists.

Must recompute on server to prevent tampering.

3.3 Data model updates (Order)
Update Order to store:

baseAmount

buyerPlatformFee

buyerProcessingFee

sellerPlatformFee

platformRevenue

grossAmount (total paid)

currency

gateway, gatewayMethod

status includes escrow states:

DRAFT|AWAITING_PAYMENT|PAID_HELD|IN_PROGRESS|RELEASED|REFUNDED|DISPUTED|CANCELLED

Remove or deprecate ambiguous fields:

totalAmount should become grossAmount (rename/migrate)

buyerFee becomes buyerPlatformFee

Keep old columns only if migration constraints require transitional compatibility.

4) ITN/Callback Handling Must Record Gross/Fee/Net & Verify Amount
4.1 PayFast ITN route
File: apps/api/src/routes/webhook.routes.ts (PayFast handler)

Required:

Validate signature (PayFast ITN recommended procedure).

Lookup order by m_payment_id.

Verify:

itn.amount_gross === order.grossAmount (exact)

itn.currency === order.currency

Upsert Transaction:

type = PAYMENT

grossAmount = amount_gross

gatewayFee = amount_fee

netAmount = amount_net

rawPayload = itn payload

status = SUCCESS

Mark order status to PAID_HELD.

Create EscrowHold entry with:

grossAmount, gatewayFee, netAmount

plus fee snapshot from order

heldAt timestamp

Idempotency:

If Transaction exists with same gatewayRef, do nothing and return 200.

4.2 Ozow callback (if exists)
Mirror behavior: gross/fee/net if provided; if not provided, store gross and compute fee estimate separately.

5) Escrow Ledger Must Be Net-Aware
5.1 Update EscrowHold model
Add:

grossAmount

gatewayFee

netAmount

buyerProcessingFee

buyerPlatformFee

sellerPlatformFee

platformRevenue

status: HELD|PARTIALLY_RELEASED|RELEASED|REFUNDED|DISPUTED

5.2 Update processEscrowHold()
File: apps/api/src/services/escrow.service.ts

Replace:

totalAmount usage with grossAmount/netAmount

Escrow ledger should represent:

What was received (net)

What is reserved for payouts

What remains as platform revenue (excluding gateway fee)

6) Implement Refund & Dispute State Machine (No TODO)
6.1 Add order dispute/refund statuses
Order:

DISPUTED (holds payouts)

REFUNDED (terminal)

CHARGEBACK (optional)

6.2 Implement refund service
In escrow.service.ts replace TODO with one of:

Manual refund mode (MVP): create a Transaction REFUND and mark order refunded, but require admin action

Gateway API refund (later): implement PayFast refund if available via your integration channel

Minimum MVP requirements:

When refund requested before release:

mark escrow hold REFUNDED

mark order REFUNDED

create Transaction REFUND (gross refund amount)

block payout creation

If refund after partial release:

mark dispute and create negative ledger adjustment; do not automatically clawback without policy.

7) Batch Payout Runner (Daily/Weekly) + Payout Fees Allocation
7.1 SellerPayout must be ledger, not instant payment
Ensure SellerPayout has:

amount

status: PENDING|PROCESSING|PAID|FAILED|CANCELLED

batchId (nullable)

externalRef (bank EFT reference)

availableAt (after escrow release + reserve period)

failureReason

7.2 Create payout batch job
Create:

apps/api/src/jobs/payout-batch.ts

Responsibilities:

Select SellerPayout where:

status=PENDING

availableAt <= now

amount >= payoutMinThreshold (config)

Mark them PROCESSING with batchId.

Output a CSV/JSON for bank EFT processing (manual MVP).

After confirmation (admin endpoint), mark PAID with externalRef.

7.3 Admin endpoints
Add:

POST /admin/payouts/batches/create

POST /admin/payouts/batches/:batchId/confirm (accept list of payout ids + references)

Keep it manual initially; automate bank EFT later.

7.4 Payout fee allocation strategy
Because PayFast payout fee is per withdrawal request from PayFast to bank, and you’re MoR:

You should not “fee” every seller payout for PayFast withdrawal.

Instead allocate payout costs into operating expenses OR allocate pro-rata per period (internal analytics).
Implement:

platformCosts.payoutFeeAllocated (optional accounting table)
Not required for MVP.

8) Update Release Logic (Milestones)
8.1 Current release function
releaseOrderEscrow() exists; ensure it can support:

full release

partial release (milestones) if your product requires it

If milestone-based:
Create:

OrderMilestone model:

amount

status: PENDING|APPROVED|RELEASED|DISPUTED

dueAt

Release flow:

Approve milestone → create SellerPayout for that milestone amount minus seller fee already accounted? (seller fee already computed on total; decide policy)
Simplest:

compute seller fee on each milestone proportionally (fee snapshot per milestone)

or compute on total and apportion.

MVP:

single milestone = whole project.

9) Update API Routes to Use New Fields
9.1 Update order creation route
File: apps/api/src/routes/order.routes.ts

Replace old fee usage with:

store the full breakdown from fee engine

set grossAmount

set gateway, method

9.2 Update payment initiation route
Where PayFast payment is initiated:

use order.grossAmount

include m_payment_id = order.id

include metadata for quote/hash if needed

9.3 Update all reads
Ensure frontend uses:

grossAmount as what buyer pays

show fee breakdown:

base amount

buyer processing

buyer platform fee

total

10) Tests & Acceptance Criteria
10.1 Unit tests for fee engine
Create tests for:

Card vs EFT costs

Minimum fees applied

Tiering applied

Gross matches base + buyer fees

10.2 ITN integrity tests
Reject if amount mismatched

Idempotent if called twice

10.3 Ledger invariants (must hold)
For any paid order:

order.grossAmount == base + buyerProcessingFee + buyerPlatformFee

platformRevenue == buyerPlatformFee + sellerPlatformFee

sellerPayoutTarget == base - sellerPlatformFee

escrow.netAmount == gross - gatewayFee (if gateway provides net)

11) Implementation Order (Do in this sequence)
Prisma schema fixes (Transaction + Order + EscrowHold + SellerPayout fields)

Migrations + update code to compile

Build fee engine + replace all old fee calculations

Add quote endpoint and adjust order creation to be method-aware

Update PayFast initiation to use grossAmount

Update ITN handler to:

verify amount/currency

record Transaction gross/fee/net

create escrow hold

idempotent

Implement refund path (manual MVP)

Implement payout batch job + admin endpoints

Add tests and sanity checks

12) Notes / Defaults to Use (MVP Config)
Use these fee policy defaults for MVP:

buyerPlatformPct = 3%

buyerPlatformMin = R10

buyerProcessingMin = R15

seller tiers:

<= R500: 12% min R15

<= R2000: 10% min R20

R2000: 8% min R30

bufferPct = 0.002

bufferFixed = R1

These are conservative. You can tune after observing AOV, payment method mix, refund rate.

13) Deliverables Checklist
 Prisma migration applied successfully

 FeeCalcOutput returned by /orders/quote

 Order persisted with new fee breakdown + grossAmount

 PayFast checkout uses grossAmount

 ITN creates Transaction with gross/fee/net + raw payload

 EscrowHold created on payment success

 Refund endpoint marks order/escrow correctly and creates REFUND transaction

 Batch payout runner creates batches and can confirm payouts

 Minimal tests pass

14) File Map (where to edit)
apps/api/prisma/schema.prisma (models + enums)

apps/api/src/routes/order.routes.ts (quote + create order changes)

apps/api/src/routes/webhook.routes.ts (PayFast ITN + idempotency + verification)

apps/api/src/services/escrow.service.ts (hold/release/refund)

apps/api/src/services/payment.service.ts (replace fee calc usage)

apps/api/src/services/fee-engine.ts (new)

apps/api/src/jobs/payout-batch.ts (new)

apps/api/src/routes/admin.payouts.routes.ts (new or extend existing)

15) Done Definition (Functional demo scenario)
Create quote for R1500 via PayFast CARD

Create order and redirect to PayFast

ITN confirms payment:

order becomes PAID_HELD

escrow hold created with gross/fee/net

Mark order complete → release escrow:

seller payout created as PENDING with availableAt

Run payout batch:

payout goes PROCESSING, exported list generated

Confirm batch:

payouts become PAID, refs stored

Refund path:

create a new order, pay, refund before release → becomes REFUNDED, no payout possible

## A) High-level decisions to implement (DO NOT DEVIATE)

### A1) Escrow model = Option A (Merchant of Record)
- Buyer pays **platform** (single PayFast/Ozow merchant).
- Platform records payment (gross/fee/net) → creates escrow hold.
- Platform releases escrow later → creates seller payout record.
- Seller payouts happen via **batch payout run** (manual bank EFT MVP).

### A2) Fee model = gateway-aware + minimums + tiering
Replace “buyerFee” with:
- `buyerPlatformFee` (e.g., 3% with min)
- `buyerProcessingFee` (covers gateway costs with min + buffer)
Seller:
- `sellerPlatformFee` (tiered, min)

**Gross amount charged to buyer**
`grossAmount = baseAmount + buyerPlatformFee + buyerProcessingFee`

**Platform revenue**
`platformRevenue = buyerPlatformFee + sellerPlatformFee`
(Gateway fee is not revenue.)

---

## B) PATCH PLAN (by file)

> Implement in this order. After each step, ensure `pnpm lint && pnpm test` (or equivalent) still passes.

---

# 1) Prisma schema: fix mismatch + add escrow-safe fields
**File:** `apps/api/prisma/schema.prisma`

## 1.1 Add enums (if not already present)
Add/merge:

```prisma
enum PaymentGateway {
  PAYFAST
  OZOW
  MANUAL
}

enum PaymentMethod {
  CARD
  EFT
  UNKNOWN
}

enum TransactionType {
  PAYMENT
  REFUND
  PAYOUT
  ADJUSTMENT
}

enum TransactionStatus {
  PENDING
  SUCCESS
  FAILED
}

enum OrderStatus {
  DRAFT
  AWAITING_PAYMENT
  PAID_HELD
  IN_PROGRESS
  RELEASED
  REFUNDED
  DISPUTED
  CANCELLED
}

enum EscrowStatus {
  HELD
  PARTIALLY_RELEASED
  RELEASED
  REFUNDED
  DISPUTED
}

enum PayoutStatus {
  PENDING
  PROCESSING
  PAID
  FAILED
  CANCELLED
}
1.2 Patch Order model
Goal: Store fee breakdown + method-aware gross.

Add/rename fields (you can keep old fields temporarily but mark deprecated):

model Order {
  id                 String        @id @default(cuid())

  // amounts
  baseAmount         Decimal
  buyerPlatformFee   Decimal        @default(0)
  buyerProcessingFee Decimal        @default(0)
  sellerPlatformFee  Decimal        @default(0)
  platformRevenue    Decimal        @default(0)

  grossAmount        Decimal        @default(0) // total buyer pays
  currency           String         @default("ZAR")

  gateway            PaymentGateway @default(PAYFAST)
  gatewayMethod      PaymentMethod  @default(UNKNOWN)

  status             OrderStatus    @default(DRAFT)

  // relations
  transactions       Transaction[]
  escrowHold         EscrowHold?
  payouts            SellerPayout[]

  createdAt          DateTime       @default(now())
  updatedAt          DateTime       @updatedAt
}
If totalAmount exists: migrate/rename semantics to grossAmount.
If you cannot rename now, add grossAmount and later deprecate totalAmount.

1.3 Patch Transaction model (THIS FIXES THE RUNTIME BREAK)
Current webhook writes fields that don’t exist. Make them exist.

model Transaction {
  id               String            @id @default(cuid())
  type             TransactionType
  status           TransactionStatus @default(PENDING)

  gateway           PaymentGateway
  gatewayRef        String?          @unique // from ITN/callback (pf_payment_id, etc)
  orderId           String?
  order             Order?           @relation(fields: [orderId], references: [id])

  grossAmount       Decimal
  gatewayFee        Decimal?         // from gateway if supplied
  netAmount         Decimal?         // from gateway if supplied
  currency          String           @default("ZAR")

  // snapshot of fee model at time of payment/refund
  buyerPlatformFee   Decimal         @default(0)
  buyerProcessingFee Decimal         @default(0)
  sellerPlatformFee  Decimal         @default(0)
  platformRevenue    Decimal         @default(0)

  rawPayload        Json?

  createdAt         DateTime         @default(now())
}
1.4 Add EscrowHold model (or patch existing)
model EscrowHold {
  id                 String      @id @default(cuid())
  orderId            String      @unique
  order              Order       @relation(fields: [orderId], references: [id])

  status             EscrowStatus @default(HELD)

  grossAmount        Decimal
  gatewayFee         Decimal?
  netAmount          Decimal?

  buyerPlatformFee   Decimal @default(0)
  buyerProcessingFee Decimal @default(0)
  sellerPlatformFee  Decimal @default(0)
  platformRevenue    Decimal @default(0)

  heldAt             DateTime @default(now())
  updatedAt          DateTime @updatedAt
}
1.5 Add/patch SellerPayout model
model SellerPayout {
  id          String      @id @default(cuid())
  orderId     String
  order       Order       @relation(fields: [orderId], references: [id])

  amount      Decimal
  currency    String      @default("ZAR")
  status      PayoutStatus @default(PENDING)

  availableAt DateTime
  batchId     String?
  externalRef String?
  failureReason String?

  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@index([status, availableAt])
  @@index([batchId])
}
1.6 Create migration
Run Prisma migration and commit generated files.

Acceptance:

Schema compiles.

Existing Prisma calls updated in later steps to match.

2) Add Fee Engine (single source of truth)
NEW FILE: apps/api/src/services/fee-engine.ts

2.1 Implement policy + fee calc
Implement this exact API:

export type Gateway = "PAYFAST" | "OZOW";
export type Method = "CARD" | "EFT" | "UNKNOWN";

export interface FeePolicy {
  buyerPlatformPct: number;   // 0.03
  buyerPlatformMin: number;   // 10
  buyerProcessingMin: number; // 15
  sellerTiers: Array<{ upTo?: number; pct: number; min: number }>;

  bufferPct: number;          // 0.002
  bufferFixed: number;        // 1
  vatPct: number;             // 0.15 (used for gateway fee estimate)
}

export interface FeeCalcInput {
  baseAmount: number;
  currency: "ZAR";
  gateway: Gateway;
  method: Method;
  policy: FeePolicy;
}

export interface FeeCalcOutput {
  baseAmount: number;

  buyerPlatformFee: number;
  buyerProcessingFee: number;

  sellerPlatformFee: number;
  platformRevenue: number;

  grossAmount: number;
  sellerPayoutTarget: number;

  estimatedGatewayFee: number;
  estimatedNetToPlatform: number;
}

export function calculateFees(input: FeeCalcInput): FeeCalcOutput {
  // implement
}
2.2 PayFast estimate rules (hardcode MVP)
Inside fee engine:

PayFast card ex VAT: feeExVat = gross*0.032 + 2

PayFast EFT ex VAT: feeExVat = max(gross*0.02, 2)

Apply VAT: feeInclVat = feeExVat * (1 + vatPct)

Add buffer: feeInclVat += feeInclVat*bufferPct + bufferFixed

Use method === "UNKNOWN" fallback to CARD estimate (more conservative).

2.3 Seller tier calc
Pick first matching tier by baseAmount <= upTo, else last tier.
Apply minimum per tier.

2.4 Rounding
Round monetary values to 2 decimals consistently:

Use Math.round(x * 100) / 100 for MVP.

Keep it consistent across all outputs.

3) Add Quote endpoint + rework order creation to be method-aware
File: apps/api/src/routes/order.routes.ts

3.1 Add POST /orders/quote
Input:

{ "baseAmount": 1500, "gateway": "PAYFAST", "method": "CARD" }
Output: FeeCalcOutput

Rules:

Validate baseAmount >= minimum (e.g., 50)

Compute fees using default policy config.

Return breakdown.

3.2 Modify POST /orders to recompute server-side
Do NOT trust client-calculated fees.

Input includes:

{ "baseAmount": 1500, "gateway": "PAYFAST", "method": "CARD", ...other order fields }
Server:

recompute FeeCalcOutput

persist Order:

baseAmount

buyerPlatformFee

buyerProcessingFee

sellerPlatformFee

platformRevenue

grossAmount

currency=ZAR

gateway, gatewayMethod

status = AWAITING_PAYMENT

Acceptance:

Order stored with correct totals.

No old calculateOrderFees(baseAmount) usage remains.

4) PayFast initiation must charge order.grossAmount
File: wherever PayFast payment is initiated (often payment.routes.ts or payment.service.ts)

4.1 Patch PayFast form/data
Use amount = order.grossAmount (NOT baseAmount)

Use m_payment_id = order.id

Ensure currency matches.

4.2 Ensure you store a gatewayRef later from ITN (pf_payment_id)
Nothing else special here.

5) ITN/webhook: verify amount + record gross/fee/net + create escrow hold
File: apps/api/src/routes/webhook.routes.ts

5.1 MUST: idempotent transaction upsert
Pseudo:

Parse ITN payload

Validate signature (if already implemented keep; if not, add)

Get order by m_payment_id

Verify:

amount_gross === order.grossAmount (exact match to cents)

currency === order.currency

Upsert Transaction:

type=PAYMENT, status=SUCCESS, gateway=PAYFAST

gatewayRef=pf_payment_id (or equivalent)

grossAmount, gatewayFee=amount_fee, netAmount=amount_net

fee snapshots from order

rawPayload = itn

If order already PAID_HELD or escrowHold exists, return 200.

Mark order PAID_HELD

Create EscrowHold with net-aware fields.

5.2 Patch schema alignment
Ensure the prisma.transaction.create() matches the new Transaction model.
Do not write fields that don’t exist.

5.3 Important: fix missing import
If scheduleEscrowRelease is imported but not defined, remove it or implement.
Do not leave broken imports.

Acceptance:

ITN called twice doesn’t double-create escrow holds.

Underpayment is rejected.

6) Escrow service: net-aware ledger + release creates SellerPayout
File: apps/api/src/services/escrow.service.ts

6.1 Patch processEscrowHold(orderId, transaction)
Change signature (recommended):

processEscrowHoldFromPayment(orderId: string, txId: string)

It should:

load order + transaction

create escrowHold using transaction gross/fee/net and order fee snapshots

6.2 Patch releaseOrderEscrow(orderId)
Rules:

only allowed when order status in PAID_HELD|IN_PROGRESS

create SellerPayout:

amount = order.baseAmount - order.sellerPlatformFee

availableAt = now + reserveDays (config, e.g., 7 days)

status=PENDING

update escrow status to RELEASED

update order status to RELEASED

Reserve policy MVP:

reserveDays = 7

7) Refund flow: remove TODO and implement manual refund MVP
File: apps/api/src/services/escrow.service.ts + routes

7.1 Add endpoint: POST /orders/:id/refund
MVP behavior:

Allowed only when order status is PAID_HELD and NOT released.

Create Transaction:

type=REFUND

status=SUCCESS (if manual confirmed) OR PENDING (if you want later confirm)

gateway=PAYFAST

grossAmount = order.grossAmount

rawPayload includes reason, requestedBy

Update escrowHold status=REFUNDED

Update order status=REFUNDED

Ensure no SellerPayout exists; if exists, block or cancel.

Note:

This is “manual refund mode” (no gateway API call). Admin will refund in PayFast dashboard.

Acceptance:

Refunded order cannot be released or paid out.

8) Batch payout runner + admin confirm endpoints
NEW FILE: apps/api/src/jobs/payout-batch.ts

8.1 Create a “create batch” function
Fetch eligible payouts:

status=PENDING

availableAt <= now

amount >= payoutMin (config, e.g., R100)

Generate batchId = "bat_" + cuid()

Update selected payouts:

status=PROCESSING

batchId set

Return batch summary + data lines for export:

payoutId, sellerId (if exists), amount, currency, orderId

MVP: Do not integrate bank API. Just export JSON/CSV.

8.2 Admin routes
File: create apps/api/src/routes/admin.payouts.routes.ts (or extend existing)

POST /admin/payouts/batches/create

calls create batch

returns export payload

POST /admin/payouts/batches/:batchId/confirm

input: list of { payoutId, externalRef }

sets each payout status=PAID, writes externalRef

POST /admin/payouts/batches/:batchId/fail

sets payouts status=FAILED and stores failureReason

Acceptance:

Batch create doesn’t include future availableAt payouts.

Confirm updates only payouts belonging to that batch.

9) Replace any remaining legacy fee calc usage
Search and destroy:

calculateOrderFees(baseAmount)

fields buyerFee meaning “platform buyer fee” must be renamed to buyerPlatformFee in code

Update all code paths to use:

order.baseAmount

order.grossAmount

fee breakdown fields

Acceptance:

No stale fields used in payment initiation or escrow computations.

10) Minimal tests (must add)
New tests: apps/api/src/services/__tests__/fee-engine.test.ts

Test matrix:

base=500 card: processing fee >= min, seller tier applied

base=1500 eft: gateway estimate lower than card

rounding: two decimals

Webhook idempotency test (if test infra exists):

call handler twice → only 1 escrowHold

C) Default config to hardcode for MVP
Place in env or config file:

buyerPlatformPct=0.03

buyerPlatformMin=10

buyerProcessingMin=15

seller tiers:

upTo 500: pct 0.12 min 15

upTo 2000: pct 0.10 min 20

else: pct 0.08 min 30

reserveDays=7

payoutMin=100

vatPct=0.15

buffers: bufferPct=0.002, bufferFixed=1

D) Definition of Done (Runbook Scenario)
POST /orders/quote base=1500 gateway=PAYFAST method=CARD returns breakdown

POST /orders creates order with grossAmount

PayFast initiation charges grossAmount

PayFast ITN:

verifies amount_gross == grossAmount

creates Transaction (PAYMENT) with gross/fee/net

sets order PAID_HELD

creates EscrowHold

Release escrow:

creates SellerPayout PENDING with availableAt now+7d

Create payout batch after availableAt:

marks payouts PROCESSING + returns export

Confirm batch:

marks payouts PAID with externalRef

Refund before release:

marks order REFUNDED + escrow REFUNDED + creates REFUND transaction

blocks payout creation

E) Quick “grep targets” to find what to patch
calculateOrderFees

buyerFee

sellerFee

totalAmount

scheduleEscrowRelease

transaction.create({ type: ... grossAmount ... }) (ensure schema matches)

amount_gross / amount_fee / amount_net handling

# Zomieks — Claude Agent Patch Spec (EXACT ROUTES + FILES FROM THIS REPO)

This spec is customized to your repo layout and current route mounting (from `apps/api/src/index.ts`).

## ✅ Current API Mount Points (Confirmed)
- Orders router: `app.use('/api/v1/orders', orderRoutes);`
- Payments router: `app.use('/api/v1/payments', paymentRoutes);`
- Webhooks router: `app.use('/webhooks', webhookRoutes);`

So the *actual* endpoints are:
- Create order: `POST /api/v1/orders`
- Initiate payment: `GET /api/v1/payments/initiate?orderId=...&gateway=...`
- PayFast ITN: `POST /webhooks/payfast`
- Ozow callback: `POST /webhooks/ozow`
- PayFast subscription ITN: `POST /webhooks/payfast/subscription`

---

# 0) Decisions to implement (from this chat)
## 0.1 Escrow model (Option A: platform is Merchant-of-Record)
- Buyer pays **platform** → platform holds internally in escrow ledger.
- Release later → create seller payout ledger.
- Payouts processed in **batches** (manual bank EFT MVP).

## 0.2 Fee model (profit-safe, gateway-aware)
Replace simplistic `calculateOrderFees(baseAmount)` with:
- `buyerPlatformFee` (your “3% buyer fee”, min applies)
- `buyerProcessingFee` (covers gateway cost, min + buffer)
- `sellerPlatformFee` (seller fee, tiered/min)

Buyer total:
`grossAmount = baseAmount + buyerPlatformFee + buyerProcessingFee`

Platform revenue:
`platformRevenue = buyerPlatformFee + sellerPlatformFee`
(Gateway fee is cost, not revenue.)

---

# 1) FILE MAP (Confirmed)
## 1.1 Routes
- `apps/api/src/routes/order.routes.ts` (contains `POST /` order creation)
- `apps/api/src/routes/payment.routes.ts` (contains `GET /initiate`)
- `apps/api/src/routes/webhook.routes.ts` (contains `POST /payfast`, `/payfast/subscription`, `/ozow`)
- `apps/api/src/index.ts` mounts routes (see section 0)

## 1.2 Services
- `apps/api/src/services/payment.service.ts` (PayFast/Ozow logic + signature/hash)
- `apps/api/src/services/escrow.service.ts` (has `processEscrowHold`, `releaseOrderEscrow`, `processRefund`, BUT `scheduleEscrowRelease` is imported in webhook routes and may be missing)

## 1.3 Prisma
- `apps/api/prisma/schema.prisma`
- `apps/api/prisma/migrations/...`

---

# 2) CRITICAL BUG TO FIX FIRST: Prisma ↔ webhook mismatch
## 2.1 The mismatch (confirmed)
`apps/api/src/routes/webhook.routes.ts` creates transactions like:

- `type`
- `grossAmount`
- `gatewayFee`
- `netAmount`
- `gatewayReference`
- `gatewayResponse`

…but your `schema.prisma` Transaction model (currently) does **not** match these field names/types.
This will throw Prisma errors at runtime.

✅ Fix by updating Prisma schema + migrations AND updating create calls to match exactly.

---

# 3) PRISMA PATCH (minimum-change, aligned with your current code)
**File:** `apps/api/prisma/schema.prisma`

## 3.1 Add/patch enums to match existing string statuses in code
Your code uses:
- Order statuses: `'PENDING_PAYMENT'`, `'IN_PROGRESS'`, `'CANCELLED'`
- Transaction statuses: `'COMPLETED'`

So either:
- keep string status fields (least risky), OR
- migrate to enums and update all code.

### MVP Recommendation (least breakage):
- Keep existing status strings if already in DB schema.
- Add new columns for escrow + fees.
- Add transaction fields used by webhook code.

## 3.2 Patch Order model (add gateway-aware amounts)
Add these fields to `Order`:
- `baseAmount` (already present)
- `buyerPlatformFee` (new)
- `buyerProcessingFee` (new)
- `sellerPlatformFee` (new)
- `platformRevenue` (already present)
- `grossAmount` (new)  ✅ buyer total
- `currency` (new, default `"ZAR"`)
- `gateway` (new, `"PAYFAST"|"OZOW"`)
- `gatewayMethod` (new, `"CARD"|"EFT"|"UNKNOWN"`)

**Important:** your code currently uses `order.totalAmount`.  
For minimal migration:
- keep `totalAmount` but **treat it as grossAmount** temporarily, OR
- add `grossAmount` and update all code to use it (preferred).

## 3.3 Patch Transaction model to match webhook create()
Add these fields (names as used in webhook code):
- `type` (string)
- `status` (string)
- `grossAmount` (Decimal)
- `gatewayFee` (Decimal nullable)
- `netAmount` (Decimal nullable)
- `gatewayReference` (string nullable)  ✅ used for pf_payment_id / ozow id
- `gatewayResponse` (Json nullable)
- `gateway` (string)
- `orderId` (relation)

Also add fee snapshots (recommended for audit, but optional MVP):
- `buyerPlatformFee`, `buyerProcessingFee`, `sellerPlatformFee`, `platformRevenue` (Decimals)

## 3.4 Add/patch EscrowHold model
Add net-aware escrow ledger:
- `orderId` (unique)
- `grossAmount`, `gatewayFee`, `netAmount`
- `status` (string: HELD/RELEASED/REFUNDED/DISPUTED)
- fee snapshots optional

## 3.5 Add/patch SellerPayout model
Ensure `SellerPayout` supports batching:
- `status` string: `PENDING|PROCESSING|PAID|FAILED`
- `availableAt` datetime (reserve)
- `batchId`, `externalRef`

## 3.6 Create migration
Run migration and commit.

Acceptance:
- Prisma generate succeeds.
- `tx.transaction.create()` in webhook routes compiles and runs.

---

# 4) ADD FEE ENGINE (remove shared calculateOrderFees usage)
## 4.1 New file
**Create:** `apps/api/src/services/fee-engine.ts`

Implement:
- gateway fee estimates (PayFast card vs EFT)
- min fees + buffers
- seller tiering/minimum

**Inputs must include payment method** because we decided to price profit-safely.

### Suggested output
Return:
- baseAmount
- buyerPlatformFee
- buyerProcessingFee
- sellerPlatformFee
- platformRevenue
- grossAmount
- sellerPayoutTarget
- estimatedGatewayFee / estimatedNetToPlatform

---

# 5) ORDER ROUTES (EXACT PATCHES)
**File:** `apps/api/src/routes/order.routes.ts`

## 5.1 Current create order endpoint (confirmed)
It is:
`router.post('/', authenticate, validate(createOrderSchema), async ...)`

It currently does:
```ts
const fees = calculateOrderFees(baseAmount);
prisma.order.create({ baseAmount: fees.baseAmount, buyerFee: fees.buyerFee, totalAmount: fees.totalAmount, ... })
5.2 Add a Quote endpoint (new)
Add:
POST /api/v1/orders/quote
inside the same router as:

router.post('/quote', authenticate, async (req,res,next)=>{...})
Input:

baseAmount OR (serviceId + packageTier) + payment method info

gateway (PAYFAST|OZOW)

method (CARD|EFT)

Output:

fee breakdown + grossAmount

5.3 Patch existing POST /api/v1/orders
Modify order creation so it:

derives baseAmount like it does today

uses your new fee engine with:

gateway = paymentGateway (already in req.body)

method = req.body.paymentMethod (add to schema)

stores:

buyerPlatformFee (instead of buyerFee)

buyerProcessingFee

sellerPlatformFee (instead of sellerFee)

grossAmount (instead of totalAmount)

platformRevenue

sets status to PENDING_PAYMENT (your payment flow expects this)

your payment initiation route queries: status: 'PENDING_PAYMENT'

⚠️ IMPORTANT: Your payment initiation route currently filters for status: 'PENDING_PAYMENT'
So DO NOT change this status name in code unless you also patch all queries and schema.

6) PAYMENT INITIATION (EXACT PATCHES)
File: apps/api/src/routes/payment.routes.ts

6.1 Current initiate endpoint (confirmed)
GET /api/v1/payments/initiate

It loads the order with:

status: 'PENDING_PAYMENT'
and sends PayFast/Ozow amount = Number(order.totalAmount).

6.2 Patch: charge buyer the correct total
Change:

PayFast amount: from order.totalAmount → order.grossAmount (preferred)

Ozow amount: same

If you keep backward compatibility:

const amountToCharge = Number(order.grossAmount ?? order.totalAmount);
Also:

Add method parameter support if you want to pre-select card vs EFT pricing.

Example: /api/v1/payments/initiate?orderId=...&gateway=PAYFAST&method=CARD

Store method on order before redirect (optional MVP).

6.3 Remove unused import
calculateOrderFees is imported here but not used.
Remove:

import { calculateOrderFees } from '@zomieks/shared';
7) WEBHOOKS (EXACT PATCHES)
File: apps/api/src/routes/webhook.routes.ts

7.1 Confirmed PayFast ITN endpoint
POST /webhooks/payfast

Current behavior:
validates IP (prod)

validates signature

if COMPLETE:

updates order status to 'IN_PROGRESS'

creates transaction with grossAmount/gatewayFee/netAmount/...

calls processEscrowHold(tx, transaction.id, order)

sends notification

Required changes (per Option A escrow decisions)
Verify amount before accepting:

grossAmount === order.grossAmount (or order.totalAmount if grossAmount not added yet)

currency match if stored

Order status should become “PAID_HELD” not IN_PROGRESS (decision from chat)

BUT if your product logic assumes IN_PROGRESS means “paid + started”, then:

introduce PAID_HELD and transition to IN_PROGRESS when seller accepts.

Ensure idempotency:

If transaction with gatewayReference = pf_payment_id exists, return 200 without duplicating escrow hold.

7.2 Fix broken import: scheduleEscrowRelease
Top of file:

import { processEscrowHold, scheduleEscrowRelease } from '@/services/escrow.service.js';
You must either:

implement scheduleEscrowRelease in escrow.service.ts, OR

remove it from imports if not used.

(Do not leave it broken.)

7.3 Confirmed Ozow webhook endpoint
POST /webhooks/ozow

Patch similarly:

verify amount equals expected gross

create transaction aligned with schema

create escrow hold

set order status paid-held

8) ESCROW SERVICE (EXACT PATCHES)
File: apps/api/src/services/escrow.service.ts

8.1 Update processEscrowHold(...)
Webhook calls:
processEscrowHold(tx, transaction.id, order)

Make it:

store grossAmount, gatewayFee, netAmount

store order fee snapshots (buyerPlatformFee, buyerProcessingFee, sellerPlatformFee, platformRevenue)

create EscrowHold row for the order (unique)

8.2 Release escrow should create SellerPayout and respect reserve
On release:

amount = order.baseAmount - order.sellerPlatformFee

availableAt = now + reserveDays (config: 7 days MVP)

create SellerPayout PENDING

mark escrow RELEASED

mark order RELEASED (or keep IN_PROGRESS until delivered; depends on your workflow)

9) REFUNDS (MVP MANUAL)
Add:
POST /api/v1/orders/:id/refund
(or admin-only route if you prefer)

Rules:

only allow refund if escrow not released

mark order REFUNDED

mark escrow REFUNDED

create Transaction type=REFUND

do NOT create payouts

MVP = manual PayFast dashboard refund; store metadata.

10) PAYOUT BATCHING (Repo already schedules payouts)
Confirmed in apps/api/src/index.ts:

import('@/services/payout.service.js').then(({ schedulePayoutProcessing }) => { ... });
So there is a payout service already. You must patch it to:

process SellerPayout in batches

not attempt per-order instant payouts

Tasks:

Find apps/api/src/services/payout.service.ts

Ensure it:

selects PENDING payouts where availableAt <= now

assigns batchId, sets PROCESSING

outputs export payload

supports confirm to PAID

11) EXACT ROUTE LIST TO UPDATE / ADD
Add
POST /api/v1/orders/quote (in order.routes.ts)

Update
POST /api/v1/orders (fee calc + new fields + status PENDING_PAYMENT)

GET /api/v1/payments/initiate (use grossAmount)

POST /webhooks/payfast (amount verification + paid-held status + idempotency)

POST /webhooks/ozow (same)

12) Acceptance Tests (Manual)
Create order → should have grossAmount breakdown fields set, status=PENDING_PAYMENT

Initiate payment → gateway gets amount=grossAmount

PayFast ITN COMPLETE → transaction created, escrow hold created, order status paid-held

Release → SellerPayout created (PENDING, availableAt in future)

Payout job runs after availableAt → batches payouts, marks PROCESSING

Confirm payout → marks PAID with externalRef

Refund before release → order REFUNDED, escrow REFUNDED, no payout possible

13) Quick Greps (DO THESE)
calculateOrderFees (remove/replace everywhere)

buyerFee / sellerFee (rename to platform vs processing)

totalAmount (treat as gross; prefer grossAmount)

status: 'PENDING_PAYMENT' (do not break payment initiation flow)

scheduleEscrowRelease (fix/remove)

Transaction field names in webhook.routes.ts must match Prisma schema exactly

# Zomieks — Claude Agent Task Checklist (Imperative + Paste-Ready Snippets)

Use this as the exact implementation queue. Keep changes minimal and compatible with existing status strings like `PENDING_PAYMENT` and `IN_PROGRESS`.

---

## 1) Patch Prisma schema to match webhook Transaction writes (STOP runtime errors)

### 1.1 Edit `apps/api/prisma/schema.prisma`
**Do this:**
- Add missing fields to `Transaction` so `webhook.routes.ts` can create rows without Prisma errors.
- Add new fields to `Order` for gateway-aware fees and buyer gross total.
- Add/patch `EscrowHold` and `SellerPayout` to support Option A.

**Paste-ready Prisma blocks (adjust field names ONLY if they already exist):**

> If you already have these models, **merge fields** rather than duplicating models.

```prisma
model Order {
  id                 String   @id @default(cuid())

  baseAmount         Decimal
  // New fee breakdown (Option A)
  buyerPlatformFee   Decimal  @default(0)
  buyerProcessingFee Decimal  @default(0)
  sellerPlatformFee  Decimal  @default(0)
  platformRevenue    Decimal  @default(0)

  // Buyer total (gross)
  grossAmount        Decimal  @default(0)
  currency           String   @default("ZAR")

  // Gateway selection
  gateway            String   @default("PAYFAST") // "PAYFAST"|"OZOW"
  gatewayMethod      String   @default("UNKNOWN") // "CARD"|"EFT"|"UNKNOWN"

  // Keep your existing status strings
  status             String   @default("PENDING_PAYMENT")

  createdAt          DateTime @default(now())
  updatedAt          DateTime @updatedAt

  transactions       Transaction[]
  escrowHold         EscrowHold?
  payouts            SellerPayout[]
}
model Transaction {
  id               String   @id @default(cuid())

  // For compatibility, keep as strings (MVP)
  type             String   // "PAYMENT"|"REFUND"|"PAYOUT"|"ADJUSTMENT"
  status           String   @default("COMPLETED") // or your existing conventions

  gateway           String   @default("PAYFAST")
  gatewayReference  String?  @unique
  orderId           String?
  order             Order?   @relation(fields: [orderId], references: [id])

  grossAmount       Decimal
  gatewayFee        Decimal?
  netAmount         Decimal?
  currency          String   @default("ZAR")

  // Snapshot of fee model at payment time (recommended)
  buyerPlatformFee   Decimal @default(0)
  buyerProcessingFee Decimal @default(0)
  sellerPlatformFee  Decimal @default(0)
  platformRevenue    Decimal @default(0)

  gatewayResponse   Json?

  createdAt         DateTime @default(now())
}
model EscrowHold {
  id                 String   @id @default(cuid())
  orderId            String   @unique
  order              Order    @relation(fields: [orderId], references: [id])

  status             String   @default("HELD") // HELD|RELEASED|REFUNDED|DISPUTED

  grossAmount        Decimal
  gatewayFee         Decimal?
  netAmount          Decimal?

  buyerPlatformFee   Decimal  @default(0)
  buyerProcessingFee Decimal  @default(0)
  sellerPlatformFee  Decimal  @default(0)
  platformRevenue    Decimal  @default(0)

  heldAt             DateTime @default(now())
  updatedAt          DateTime @updatedAt
}
model SellerPayout {
  id            String   @id @default(cuid())
  orderId       String
  order         Order    @relation(fields: [orderId], references: [id])

  amount        Decimal
  currency      String   @default("ZAR")
  status        String   @default("PENDING") // PENDING|PROCESSING|PAID|FAILED|CANCELLED

  availableAt   DateTime
  batchId       String?
  externalRef   String?
  failureReason String?

  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  @@index([status, availableAt])
  @@index([batchId])
}
1.2 Create migration
Do this:

Run prisma migrate dev and commit migration files.

Run prisma generate.

2) Add a fee engine (single source of truth for buyer/seller fees + gateway costs)
2.1 Create apps/api/src/services/fee-engine.ts
Paste this entire file:

// apps/api/src/services/fee-engine.ts

export type Gateway = "PAYFAST" | "OZOW";
export type Method = "CARD" | "EFT" | "UNKNOWN";

export interface FeePolicy {
  buyerPlatformPct: number;   // 0.03
  buyerPlatformMin: number;   // 10
  buyerProcessingMin: number; // 15

  sellerTiers: Array<{ upTo?: number; pct: number; min: number }>;

  bufferPct: number;          // 0.002
  bufferFixed: number;        // 1
  vatPct: number;             // 0.15
}

export interface FeeCalcInput {
  baseAmount: number;
  currency: "ZAR";
  gateway: Gateway;
  method: Method;
  policy: FeePolicy;
}

export interface FeeCalcOutput {
  baseAmount: number;

  buyerPlatformFee: number;
  buyerProcessingFee: number;

  sellerPlatformFee: number;
  platformRevenue: number;

  grossAmount: number;
  sellerPayoutTarget: number;

  estimatedGatewayFee: number;
  estimatedNetToPlatform: number;
}

const round2 = (n: number) => Math.round(n * 100) / 100;
const max2 = (a: number, b: number) => (a > b ? a : b);

function estimatePayfastFeeInclVat(
  gross: number,
  method: Method,
  vatPct: number
): number {
  // PayFast fees are published ex VAT:
  // CARD: 3.2% + R2
  // EFT: 2% (min R2)
  const m = method === "UNKNOWN" ? "CARD" : method;

  const feeExVat =
    m === "EFT"
      ? Math.max(gross * 0.02, 2)
      : gross * 0.032 + 2;

  return feeExVat * (1 + vatPct);
}

function pickSellerTier(
  baseAmount: number,
  tiers: Array<{ upTo?: number; pct: number; min: number }>
) {
  for (const t of tiers) {
    if (t.upTo == null) return t;
    if (baseAmount <= t.upTo) return t;
  }
  return tiers[tiers.length - 1];
}

export function defaultFeePolicy(): FeePolicy {
  return {
    buyerPlatformPct: 0.03,
    buyerPlatformMin: 10,
    buyerProcessingMin: 15,
    sellerTiers: [
      { upTo: 500, pct: 0.12, min: 15 },
      { upTo: 2000, pct: 0.10, min: 20 },
      { pct: 0.08, min: 30 },
    ],
    bufferPct: 0.002,
    bufferFixed: 1,
    vatPct: 0.15,
  };
}

export function calculateFees(input: FeeCalcInput): FeeCalcOutput {
  const { baseAmount, gateway, method, policy } = input;
  if (!Number.isFinite(baseAmount) || baseAmount <= 0) {
    throw new Error("Invalid baseAmount");
  }

  const buyerPlatformFee = round2(
    max2(baseAmount * policy.buyerPlatformPct, policy.buyerPlatformMin)
  );

  const sellerTier = pickSellerTier(baseAmount, policy.sellerTiers);
  const sellerPlatformFee = round2(
    max2(baseAmount * sellerTier.pct, sellerTier.min)
  );

  // We must estimate gateway fees on the full gross. But gross includes processing fee.
  // Solve by iterating once: start with processing min, compute gross, estimate fee, set processing to fee+buffer.
  const startProcessing = policy.buyerProcessingMin;

  const gross0 = baseAmount + buyerPlatformFee + startProcessing;
  const estGateway0 =
    gateway === "PAYFAST"
      ? estimatePayfastFeeInclVat(gross0, method, policy.vatPct)
      : estimatePayfastFeeInclVat(gross0, method, policy.vatPct); // placeholder for OZOW; replace later

  const estGatewayBuffered =
    estGateway0 + estGateway0 * policy.bufferPct + policy.bufferFixed;

  const buyerProcessingFee = round2(
    max2(estGatewayBuffered, policy.buyerProcessingMin)
  );

  const grossAmount = round2(baseAmount + buyerPlatformFee + buyerProcessingFee);
  const estimatedGatewayFee =
    gateway === "PAYFAST"
      ? round2(estimatePayfastFeeInclVat(grossAmount, method, policy.vatPct))
      : round2(estimatePayfastFeeInclVat(grossAmount, method, policy.vatPct)); // replace later

  const platformRevenue = round2(buyerPlatformFee + sellerPlatformFee);
  const sellerPayoutTarget = round2(baseAmount - sellerPlatformFee);
  const estimatedNetToPlatform = round2(grossAmount - estimatedGatewayFee);

  return {
    baseAmount: round2(baseAmount),
    buyerPlatformFee,
    buyerProcessingFee,
    sellerPlatformFee,
    platformRevenue,
    grossAmount,
    sellerPayoutTarget,
    estimatedGatewayFee,
    estimatedNetToPlatform,
  };
}
3) Add quote endpoint and rework order creation to be gateway/method-aware
3.1 Patch apps/api/src/routes/order.routes.ts
3.1.1 Import fee engine
Add near top:

import { calculateFees, defaultFeePolicy, type Gateway, type Method } from '@/services/fee-engine.js';
3.1.2 Add POST /api/v1/orders/quote
Add BEFORE router.post('/', ...):

router.post('/quote', authenticate, async (req, res, next) => {
  try {
    const { baseAmount, gateway = "PAYFAST", method = "CARD" } = req.body ?? {};
    const fees = calculateFees({
      baseAmount: Number(baseAmount),
      currency: "ZAR",
      gateway: gateway as Gateway,
      method: method as Method,
      policy: defaultFeePolicy(),
    });
    return res.json({ success: true, fees });
  } catch (err) {
    return next(err);
  }
});
3.1.3 Patch POST /api/v1/orders to store breakdown
Inside your existing order creation handler, replace old fee logic:

Find and remove:

calculateOrderFees(baseAmount) (and any shared import)

Replace with:

const gateway = (req.body?.paymentGateway ?? "PAYFAST") as Gateway;
const method = (req.body?.paymentMethod ?? "CARD") as Method;

const fees = calculateFees({
  baseAmount: Number(baseAmount),
  currency: "ZAR",
  gateway,
  method,
  policy: defaultFeePolicy(),
});

const order = await tx.order.create({
  data: {
    // existing fields...
    baseAmount: fees.baseAmount,

    buyerPlatformFee: fees.buyerPlatformFee,
    buyerProcessingFee: fees.buyerProcessingFee,
    sellerPlatformFee: fees.sellerPlatformFee,
    platformRevenue: fees.platformRevenue,

    grossAmount: fees.grossAmount,
    currency: "ZAR",
    gateway,
    gatewayMethod: method,

    status: 'PENDING_PAYMENT', // DO NOT break initiate flow
  }
});
If your schema still uses buyerFee/sellerFee/totalAmount, map them temporarily:

buyerFee = fees.buyerPlatformFee

sellerFee = fees.sellerPlatformFee

totalAmount = fees.grossAmount

4) Patch payment initiation to charge buyer grossAmount
4.1 Patch apps/api/src/routes/payment.routes.ts
In GET /initiate, change amount selection:

Replace:

const amount = Number(order.totalAmount);
With:

const amount = Number((order as any).grossAmount ?? (order as any).totalAmount);
Also remove unused import:

calculateOrderFees from @zomieks/shared (it’s currently unused).

5) Patch PayFast ITN to verify amount, be idempotent, and create net-aware escrow hold
5.1 Patch apps/api/src/routes/webhook.routes.ts — PayFast ITN handler
In POST /payfast, add these steps in this exact order:

5.1.1 Load order and verify amount
After you parse itnData, before you update order:

const order = await prisma.order.findUnique({
  where: { id: itnData.m_payment_id },
});

if (!order) {
  return res.status(404).send('Order not found');
}

const expectedGross = Number((order as any).grossAmount ?? (order as any).totalAmount);
const receivedGross = Number(itnData.amount_gross);

if (Math.round(receivedGross * 100) !== Math.round(expectedGross * 100)) {
  // reject under/over-payments
  return res.status(400).send('Amount mismatch');
}
5.1.2 Idempotency: if transaction exists for pf_payment_id, exit
Before creating a new transaction:

const existingTx = await prisma.transaction.findFirst({
  where: { gatewayReference: itnData.pf_payment_id },
});

if (existingTx) {
  return res.status(200).send('OK');
}
5.1.3 Create transaction using schema-aligned fields
Replace transaction create with:

const transaction = await prisma.transaction.create({
  data: {
    type: 'PAYMENT',
    status: 'COMPLETED',
    gateway: 'PAYFAST',
    gatewayReference: itnData.pf_payment_id,
    orderId: order.id,

    grossAmount: itnData.amount_gross,
    gatewayFee: itnData.amount_fee,
    netAmount: itnData.amount_net,
    currency: 'ZAR',

    buyerPlatformFee: (order as any).buyerPlatformFee ?? (order as any).buyerFee ?? 0,
    buyerProcessingFee: (order as any).buyerProcessingFee ?? 0,
    sellerPlatformFee: (order as any).sellerPlatformFee ?? (order as any).sellerFee ?? 0,
    platformRevenue: (order as any).platformRevenue ?? 0,

    gatewayResponse: itnData,
  },
});
5.1.4 Update order status to “PAID_HELD” (or keep IN_PROGRESS if your flow requires)
Per this chat, we want PAID_HELD after payment.
If your UI expects IN_PROGRESS, do:

set PAID_HELD now

transition to IN_PROGRESS when seller accepts

Patch:

await prisma.order.update({
  where: { id: order.id },
  data: { status: 'PAID_HELD' },
});
If you cannot change status yet, keep IN_PROGRESS and still create escrow hold.

5.1.5 Create escrow hold (unique per order)
Call escrow service or inline create:

await prisma.escrowHold.upsert({
  where: { orderId: order.id },
  update: {
    status: 'HELD',
    grossAmount: itnData.amount_gross,
    gatewayFee: itnData.amount_fee,
    netAmount: itnData.amount_net,
    buyerPlatformFee: (order as any).buyerPlatformFee ?? (order as any).buyerFee ?? 0,
    buyerProcessingFee: (order as any).buyerProcessingFee ?? 0,
    sellerPlatformFee: (order as any).sellerPlatformFee ?? (order as any).sellerFee ?? 0,
    platformRevenue: (order as any).platformRevenue ?? 0,
  },
  create: {
    orderId: order.id,
    status: 'HELD',
    grossAmount: itnData.amount_gross,
    gatewayFee: itnData.amount_fee,
    netAmount: itnData.amount_net,
    buyerPlatformFee: (order as any).buyerPlatformFee ?? (order as any).buyerFee ?? 0,
    buyerProcessingFee: (order as any).buyerProcessingFee ?? 0,
    sellerPlatformFee: (order as any).sellerPlatformFee ?? (order as any).sellerFee ?? 0,
    platformRevenue: (order as any).platformRevenue ?? 0,
  },
});
5.1.6 Fix scheduleEscrowRelease import
At top of file, either:

remove scheduleEscrowRelease from import if unused, OR

implement it.

Do NOT leave broken imports.

6) Patch Ozow webhook similarly
6.1 Patch apps/api/src/routes/webhook.routes.ts — Ozow handler
Implement:

load order

verify amount equals expected gross

idempotent transaction creation by gatewayReference

create escrowHold upsert

set order status paid-held

Use same patterns as PayFast.

7) Implement release escrow -> create SellerPayout with reserve
7.1 Patch apps/api/src/services/escrow.service.ts
In releaseOrderEscrow(orderId):

Add:

compute payout amount = baseAmount - sellerPlatformFee

create SellerPayout:

status=PENDING

availableAt = now + 7 days (MVP)

Paste-ready snippet:

const reserveDays = 7;
const availableAt = new Date(Date.now() + reserveDays * 24 * 60 * 60 * 1000);

const payoutAmount = Number(order.baseAmount) - Number((order as any).sellerPlatformFee ?? (order as any).sellerFee ?? 0);

await tx.sellerPayout.create({
  data: {
    orderId: order.id,
    amount: payoutAmount,
    currency: (order as any).currency ?? 'ZAR',
    status: 'PENDING',
    availableAt,
  }
});

await tx.escrowHold.update({
  where: { orderId: order.id },
  data: { status: 'RELEASED' },
});

await tx.order.update({
  where: { id: order.id },
  data: { status: 'RELEASED' },
});
8) Implement refund endpoint (manual refund MVP)
8.1 Add route in apps/api/src/routes/order.routes.ts
Add:

router.post('/:id/refund', authenticate, async (req, res, next) => {
  try {
    const orderId = req.params.id;

    const order = await prisma.order.findUnique({ where: { id: orderId }, include: { escrowHold: true } });
    if (!order) return res.status(404).json({ success: false, error: 'Order not found' });

    if (order.status === 'RELEASED') {
      return res.status(400).json({ success: false, error: 'Cannot refund after release (policy needed)' });
    }

    // record refund transaction (manual mode)
    await prisma.transaction.create({
      data: {
        type: 'REFUND',
        status: 'COMPLETED',
        gateway: (order as any).gateway ?? 'PAYFAST',
        gatewayReference: `refund_${order.id}_${Date.now()}`,
        orderId: order.id,
        grossAmount: (order as any).grossAmount ?? (order as any).totalAmount,
        currency: (order as any).currency ?? 'ZAR',
        buyerPlatformFee: (order as any).buyerPlatformFee ?? (order as any).buyerFee ?? 0,
        buyerProcessingFee: (order as any).buyerProcessingFee ?? 0,
        sellerPlatformFee: (order as any).sellerPlatformFee ?? (order as any).sellerFee ?? 0,
        platformRevenue: (order as any).platformRevenue ?? 0,
        gatewayResponse: { reason: req.body?.reason ?? 'manual refund' },
      }
    });

    // update escrow + order
    if (order.escrowHold) {
      await prisma.escrowHold.update({ where: { orderId: order.id }, data: { status: 'REFUNDED' } });
    }

    await prisma.order.update({ where: { id: order.id }, data: { status: 'REFUNDED' } });

    return res.json({ success: true });
  } catch (err) {
    return next(err);
  }
});
9) Patch payout batching using existing scheduler hook
You already call schedulePayoutProcessing from apps/api/src/index.ts.

9.1 Edit apps/api/src/services/payout.service.ts
Do this:

Ensure scheduled job selects payouts:

status = 'PENDING'

availableAt <= now

amount >= 100

Assign batchId and set PROCESSING

Return export payload (log it or store it)

Paste-ready core query:

const now = new Date();
const payoutMin = 100;

const payouts = await prisma.sellerPayout.findMany({
  where: {
    status: 'PENDING',
    availableAt: { lte: now },
    amount: { gte: payoutMin },
  },
  take: 200,
});
Batch update:

const batchId = `bat_${Date.now()}_${Math.random().toString(16).slice(2)}`;

await prisma.sellerPayout.updateMany({
  where: { id: { in: payouts.map(p => p.id) } },
  data: { status: 'PROCESSING', batchId },
});
10) Add admin payout confirm endpoints (minimal)
Create new file:
apps/api/src/routes/admin.payouts.routes.ts

Mount it in apps/api/src/index.ts:

import adminPayoutRoutes from './routes/admin.payouts.routes.js';
app.use('/api/v1/admin/payouts', adminPayoutRoutes);
In the router:

POST /batches/:batchId/confirm sets payouts to PAID with externalRef.

Paste-ready:

router.post('/batches/:batchId/confirm', authenticate, async (req,res,next)=>{
  try{
    const { batchId } = req.params;
    const items = Array.isArray(req.body?.items) ? req.body.items : [];

    for (const it of items) {
      await prisma.sellerPayout.update({
        where: { id: it.payoutId },
        data: { status: 'PAID', externalRef: String(it.externalRef ?? '') },
      });
    }

    return res.json({ success: true });
  }catch(err){ return next(err); }
});
11) Remove legacy fee usage everywhere
Run:

grep calculateOrderFees

grep buyerFee

grep totalAmount
Update to:

fee-engine breakdown fields

grossAmount for charging buyer

12) Manual “done” scenario (must pass)
POST /api/v1/orders/quote → returns fees

POST /api/v1/orders → order has grossAmount + breakdown + status PENDING_PAYMENT

GET /api/v1/payments/initiate?orderId=...&gateway=PAYFAST → amount uses grossAmount

POST /webhooks/payfast → verifies amount, idempotent, creates tx + escrow hold, sets paid-held

Release escrow (your existing endpoint) → creates SellerPayout PENDING with reserve

Scheduler picks payouts when availableAt passes → marks PROCESSING with batchId

Confirm payout → marks PAID with refs

Refund before release → sets REFUNDED, no payout possible

# Zomieks — Claude Agent Search/Replace Map (Repo-Tailored)

Use this as a mechanical refactor guide AFTER you add the new fields to Prisma and implement the fee engine. The goal is to remove ambiguous fee naming and ensure the buyer is charged the correct **grossAmount** (base + buyer fees) while the escrow ledger tracks net.

---

## 0) Golden meanings (DO NOT MIX THESE UP)

- `baseAmount` = the service/project price (seller’s listed price before seller fee)
- `buyerPlatformFee` = your buyer marketplace fee (your “3% buyer fee”)
- `buyerProcessingFee` = fee that covers gateway cost (min + buffer), charged to buyer
- `sellerPlatformFee` = seller commission fee (tier/min), taken from base
- `platformRevenue` = buyerPlatformFee + sellerPlatformFee (NOT including gateway fee)
- `grossAmount` = baseAmount + buyerPlatformFee + buyerProcessingFee (what buyer pays)
- `gatewayFee` = payment processor fee (cost)
- `netAmount` = grossAmount - gatewayFee (money you actually receive)

---

## 1) Literal search terms and what to replace them with

### 1.1 `calculateOrderFees(`
**Replace usage with:** `calculateFees({ ... })` from `@/services/fee-engine.js`

**Search:**  
- `calculateOrderFees(`

**Replace pattern:**
- Replace entire call and returned object with:
  - `const fees = calculateFees({ baseAmount: Number(baseAmount), currency: 'ZAR', gateway, method, policy: defaultFeePolicy() });`

---

### 1.2 `buyerFee`
Your repo currently uses `buyerFee` as “buyer fee” (but we now split buyer fee into platform + processing).

**Search (all):**
- `.buyerFee`
- `buyerFee:`
- `buyerFee )`
- `'buyerFee'`

**Replacement rules:**
1) If it represents “the buyer marketplace fee (3%)” → replace with:
   - `buyerPlatformFee`

2) If it was used to compute the total to charge → replace logic to include:
   - `buyerPlatformFee + buyerProcessingFee`

**Common exact replacements:**
- `order.buyerFee` → `order.buyerPlatformFee ?? order.buyerFee`
  - (temporary compatibility if you keep old field)

- `buyerFee: fees.buyerFee` → `buyerPlatformFee: fees.buyerPlatformFee`

---

### 1.3 `sellerFee`
**Search:**
- `.sellerFee`
- `sellerFee:`
- `'sellerFee'`

**Replacement:**
- `sellerFee` → `sellerPlatformFee`

**Common exact replacements:**
- `order.sellerFee` → `order.sellerPlatformFee ?? order.sellerFee`
- `sellerFee: fees.sellerFee` → `sellerPlatformFee: fees.sellerPlatformFee`

---

### 1.4 `totalAmount`
In your repo, `totalAmount` is currently used as “buyer total.”  
We want this to be `grossAmount`.

**Search:**
- `.totalAmount`
- `totalAmount:`
- `'totalAmount'`

**Replacement:**
- Where it is “what buyer pays” → `grossAmount`

**Safe transitional pattern (if old field remains):**
- `Number(order.totalAmount)` → `Number(order.grossAmount ?? order.totalAmount)`
- `order.totalAmount` → `order.grossAmount ?? order.totalAmount`

---

### 1.5 `platformFee`
In escrow code, you have a concept like:
- `platformFee = buyerFee + sellerFee`

**Search:**
- `platformFee`
- `platform_fee`
- `platform fee`

**Replacement meaning:**
- rename to `platformRevenue` and compute:
  - `platformRevenue = buyerPlatformFee + sellerPlatformFee`

---

### 1.6 `sellerPayout` / `sellerPayoutAmount`
You likely compute seller payout as:
- `baseAmount - sellerFee`

**Search:**
- `sellerPayout`
- `sellerPayoutAmount`
- `sellerAmount`

**Replacement meaning:**
- Use:
  - `sellerPayoutTarget = baseAmount - sellerPlatformFee`

Also ensure it’s not mistakenly using gross.

---

## 2) High-risk places to patch (with exact “before → after” patterns)

### 2.1 Order creation (in `apps/api/src/routes/order.routes.ts`)
**Before (typical):**
```ts
const fees = calculateOrderFees(baseAmount);
buyerFee: fees.buyerFee,
sellerFee: fees.sellerFee,
totalAmount: fees.totalAmount,
platformRevenue: fees.platformRevenue,
After:

const fees = calculateFees({ baseAmount: Number(baseAmount), currency: "ZAR", gateway, method, policy: defaultFeePolicy() });

buyerPlatformFee: fees.buyerPlatformFee,
buyerProcessingFee: fees.buyerProcessingFee,
sellerPlatformFee: fees.sellerPlatformFee,
platformRevenue: fees.platformRevenue,
grossAmount: fees.grossAmount,
gateway,
gatewayMethod: method,
If you must maintain old columns temporarily:

buyerFee: fees.buyerPlatformFee,
sellerFee: fees.sellerPlatformFee,
totalAmount: fees.grossAmount,
2.2 Payment initiation (in apps/api/src/routes/payment.routes.ts)
Before:

const amount = Number(order.totalAmount);
After:

const amount = Number((order as any).grossAmount ?? (order as any).totalAmount);
2.3 PayFast ITN (in apps/api/src/routes/webhook.routes.ts)
Before:

Accepts payment without verifying against stored totals.

After (must add):

const expectedGross = Number((order as any).grossAmount ?? (order as any).totalAmount);
const receivedGross = Number(itnData.amount_gross);
if (Math.round(receivedGross * 100) !== Math.round(expectedGross * 100)) {
  return res.status(400).send('Amount mismatch');
}
2.4 Escrow hold creation (in escrow.service.ts or inline webhook)
Before:

uses order.totalAmount as hold total

After:

store:

grossAmount (paid)

gatewayFee, netAmount (from ITN)

fee snapshots from order

2.5 Seller payout creation (release escrow)
Before:

uses order.sellerPayout or order.sellerPayoutAmount (may not exist) or uses totals incorrectly

After:

const sellerFee = Number((order as any).sellerPlatformFee ?? (order as any).sellerFee ?? 0);
const payoutAmount = Number(order.baseAmount) - sellerFee;
3) Add these new request fields (API contracts)
Update validation schemas (Zod/Joi) to accept:

paymentGateway (already exists)

paymentMethod (NEW: CARD|EFT|UNKNOWN)

Search validation schema files for:

createOrderSchema

paymentGateway

Add:

paymentMethod: z.enum(['CARD','EFT','UNKNOWN']).optional()

4) Quick command list for Claude to run
grep -R "calculateOrderFees" -n apps/api/src

grep -R "buyerFee" -n apps/api/src

grep -R "sellerFee" -n apps/api/src

grep -R "totalAmount" -n apps/api/src

Patch each hit using the rules above.

Run Prisma migration/generate.

Run tests/lint.

5) End state checklist (validate refactor)
 Order stores: baseAmount, buyerPlatformFee, buyerProcessingFee, sellerPlatformFee, grossAmount

 Payment initiation charges: grossAmount

 ITN verifies: amount_gross matches grossAmount

 Transaction stores: gross/gatewayFee/net + snapshots

 EscrowHold stores: gross/gatewayFee/net + snapshots

 SellerPayout amount uses: baseAmount - sellerPlatformFee

 No remaining use of calculateOrderFees

 # Zomieks — Grep Hit Decision Table (How to Refactor Each Occurrence Correctly)

This table tells the agent exactly what to do when it finds `buyerFee`, `sellerFee`, `totalAmount`, or related terms. Use it while stepping through `grep -R ...` results.

---

## 1) `buyerFee` — Decide what it means in that line

### Pattern A: `buyerFee` is used for **display** (“buyer fee”, “service fee”)
**Examples to look for:**
- UI responses / JSON payloads like `{ buyerFee: order.buyerFee }`
- Email / notification templates
- Order detail endpoints returning fee breakdown

✅ **Action:**
- Replace with `buyerPlatformFee` (your 3% marketplace buyer fee)
- Also return `buyerProcessingFee` separately

**Replace:**
- `buyerFee` → `buyerPlatformFee`
- Add: `buyerProcessingFee`

**Result payload example:**
```ts
{
  baseAmount: order.baseAmount,
  buyerPlatformFee: order.buyerPlatformFee,
  buyerProcessingFee: order.buyerProcessingFee,
  grossAmount: order.grossAmount
}
Pattern B: buyerFee is used to compute what buyer pays
Examples:

totalAmount = baseAmount + buyerFee

amount = order.totalAmount where totalAmount was built using buyerFee

platformFee = buyerFee + sellerFee is fine (but rename)

✅ Action:

Replace the computation so the buyer pays:
grossAmount = baseAmount + buyerPlatformFee + buyerProcessingFee

Replace:

buyerFee in totals context → buyerPlatformFee

Add buyerProcessingFee

Before:

const totalAmount = baseAmount + buyerFee;
After:

const grossAmount = baseAmount + buyerPlatformFee + buyerProcessingFee;
Pattern C: buyerFee is stored/loaded from DB field buyerFee
Examples:

Prisma create/update: buyerFee: fees.buyerFee

Access: order.buyerFee

✅ Action options:

Preferred: migrate DB to buyerPlatformFee and stop using buyerFee

Transitional: keep buyerFee but treat it as buyerPlatformFee until fully migrated

Transitional safe read:

const buyerPlatformFee = Number((order as any).buyerPlatformFee ?? (order as any).buyerFee ?? 0);
Transitional safe write:

buyerPlatformFee: fees.buyerPlatformFee,
buyerProcessingFee: fees.buyerProcessingFee,
// optionally keep legacy:
buyerFee: fees.buyerPlatformFee,
2) sellerFee — Decide what it means
Pattern A: seller fee is used as commission
Examples:

sellerFee = baseAmount * 0.08

sellerPayout = baseAmount - sellerFee

✅ Action:

Replace sellerFee → sellerPlatformFee (tiered/min)

Ensure payout uses baseAmount only (NOT gross)

Before:

const sellerPayout = baseAmount - sellerFee;
After:

const sellerPayout = baseAmount - sellerPlatformFee;
Pattern B: seller fee included in “platformFee/platformRevenue”
✅ Action:

Replace platformFee variable name with platformRevenue

Compute:
platformRevenue = buyerPlatformFee + sellerPlatformFee

3) totalAmount — Decide what it means in that line
Pattern A: totalAmount is used as amount charged to gateway
Examples:

PayFast initiation: amount = order.totalAmount

Ozow initiation: amount = order.totalAmount

✅ Action:

Replace with grossAmount

Transitional safe read:

const amountToCharge = Number((order as any).grossAmount ?? (order as any).totalAmount);
Pattern B: totalAmount is used as order summary (buyer total)
✅ Action:

Return/display grossAmount instead

Optionally keep totalAmount in API response only if your frontend expects it (but make it equal to grossAmount)

Pattern C: totalAmount is used as escrow held amount
For Option A escrow ledger you must store:

grossAmount (paid)

gatewayFee and netAmount from webhook

✅ Action:

Do not use totalAmount for “net”.

Create EscrowHold with:

grossAmount = ITN amount_gross

gatewayFee = ITN amount_fee

netAmount = ITN amount_net

4) platformRevenue / platformFee — Decide what it means
Pattern A: platformRevenue = buyerFee + sellerFee
✅ Action:

Rename variable to platformRevenue

Replace buyerFee with buyerPlatformFee

Keep sellerPlatformFee

Before:

const platformFee = buyerFee + sellerFee;
After:

const platformRevenue = buyerPlatformFee + sellerPlatformFee;
Pattern B: platform revenue incorrectly includes gateway fees
If you see:

platformRevenue = totalAmount - sellerPayout
or anything subtracting from gross without accounting gateway

✅ Action:

Set platformRevenue explicitly:
buyerPlatformFee + sellerPlatformFee

Treat gateway fees as cost.

5) Webhook / ITN occurrences — Mandatory rules
When you see any of these:

amount_gross

amount_fee

amount_net

pf_payment_id

✅ Action ALWAYS:

Verify amount_gross equals expected gross from order

Idempotency: do not create duplicates for same pf_payment_id

Store tx:

grossAmount/gatewayFee/netAmount

Create EscrowHold upsert (unique orderId)

Decision snippet (paste-ready):

const expectedGross = Number((order as any).grossAmount ?? (order as any).totalAmount);
const receivedGross = Number(itnData.amount_gross);
if (Math.round(receivedGross * 100) !== Math.round(expectedGross * 100)) {
  return res.status(400).send('Amount mismatch');
}
const existingTx = await prisma.transaction.findFirst({ where: { gatewayReference: itnData.pf_payment_id } });
if (existingTx) return res.status(200).send('OK');
6) Seller payout occurrences — Mandatory rules
When you see:

create payout

SellerPayout.create

sellerPayoutAmount

payoutAmount

✅ Action ALWAYS:

payout based on base amount minus seller fee:
payoutAmount = baseAmount - sellerPlatformFee

apply reserve delay via availableAt

Paste-ready:

const sellerFee = Number((order as any).sellerPlatformFee ?? (order as any).sellerFee ?? 0);
const payoutAmount = Number(order.baseAmount) - sellerFee;
7) Grep workflow (how to apply the table)
Run in this exact order:

grep -R "calculateOrderFees" -n apps/api/src

Replace all uses with fee-engine calculateFees.

grep -R "\.buyerFee\b\|buyerFee:" -n apps/api/src

For each hit: classify as Display vs Totals vs DB mapping and apply above rules.

grep -R "\.sellerFee\b\|sellerFee:" -n apps/api/src

grep -R "\.totalAmount\b\|totalAmount:" -n apps/api/src

grep -R "amount_gross\|amount_fee\|amount_net\|pf_payment_id" -n apps/api/src

Apply webhook mandatory rules.

grep -R "SellerPayout\|payoutAmount\|sellerPayout" -n apps/api/src

Enforce payout formula + reserve.


# Claude Prompt — Implement Option A Escrow + Profit-Safe Fees in Zomieks (Exact Repo Paths)

You are operating on a Zomieks repo with an API at `apps/api`. Implement the decisions below exactly, with minimal breaking changes (keep existing status strings like `PENDING_PAYMENT` where needed). Output code changes and migrations; do not hand-wave.

---

## ✅ Decisions (must implement)
### 1) Escrow model = Option A (Merchant-of-Record)
- Buyer pays the platform (single merchant account).
- Platform records payment gross/fee/net via webhook (PayFast ITN / Ozow callback).
- Platform holds funds internally in an escrow ledger.
- Platform releases escrow later and creates a seller payout ledger entry.
- Seller payouts run in **batches** (manual bank EFT MVP).

### 2) Fee model = gateway-aware + minimums + tiering
Replace single `buyerFee` with:
- `buyerPlatformFee` (e.g. 3% buyer marketplace fee)
- `buyerProcessingFee` (covers gateway fees + buffer; minimum applies)
Seller fee:
- `sellerPlatformFee` (tiered + minimum)

Buyer pays:
`grossAmount = baseAmount + buyerPlatformFee + buyerProcessingFee`

Platform revenue:
`platformRevenue = buyerPlatformFee + sellerPlatformFee`
(Gateway fee is a cost, not revenue.)

---

## ✅ Confirmed API mount points (do not change)
In `apps/api/src/index.ts`:
- `app.use('/api/v1/orders', orderRoutes);`
- `app.use('/api/v1/payments', paymentRoutes);`
- `app.use('/webhooks', webhookRoutes);`

So actual endpoints are:
- `POST /api/v1/orders`
- `GET /api/v1/payments/initiate?orderId=...&gateway=...`
- `POST /webhooks/payfast`
- `POST /webhooks/ozow`
- `POST /webhooks/payfast/subscription`

---

# TASKS (Implement in order)

---

## Task 1 — Patch Prisma schema to match webhook Transaction creates (critical runtime bug)
### File: `apps/api/prisma/schema.prisma`
Problem: `apps/api/src/routes/webhook.routes.ts` creates Transaction fields like `type`, `grossAmount`, `gatewayFee`, `netAmount`, `gatewayReference`, `gatewayResponse`, but Prisma schema does not match → runtime error.

### Do:
1) Add/patch models with these fields (keep string statuses for MVP).
2) Add new fee breakdown fields to `Order` and introduce `grossAmount`.
3) Add net-aware `EscrowHold`.
4) Add batch-ready `SellerPayout`.

### Paste-ready Prisma blocks (merge into existing models; do not duplicate):

```prisma
model Order {
  id                 String   @id @default(cuid())

  baseAmount         Decimal

  buyerPlatformFee   Decimal  @default(0)
  buyerProcessingFee Decimal  @default(0)
  sellerPlatformFee  Decimal  @default(0)
  platformRevenue    Decimal  @default(0)

  grossAmount        Decimal  @default(0)
  currency           String   @default("ZAR")

  gateway            String   @default("PAYFAST")
  gatewayMethod      String   @default("UNKNOWN")

  status             String   @default("PENDING_PAYMENT")

  createdAt          DateTime @default(now())
  updatedAt          DateTime @updatedAt

  transactions       Transaction[]
  escrowHold         EscrowHold?
  payouts            SellerPayout[]
}
model Transaction {
  id               String   @id @default(cuid())

  type             String
  status           String   @default("COMPLETED")

  gateway          String   @default("PAYFAST")
  gatewayReference String?  @unique

  orderId          String?
  order            Order?   @relation(fields: [orderId], references: [id])

  grossAmount      Decimal
  gatewayFee       Decimal?
  netAmount        Decimal?
  currency         String   @default("ZAR")

  buyerPlatformFee   Decimal @default(0)
  buyerProcessingFee Decimal @default(0)
  sellerPlatformFee  Decimal @default(0)
  platformRevenue    Decimal @default(0)

  gatewayResponse  Json?
  createdAt        DateTime @default(now())
}
model EscrowHold {
  id                 String   @id @default(cuid())
  orderId            String   @unique
  order              Order    @relation(fields: [orderId], references: [id])

  status             String   @default("HELD")

  grossAmount        Decimal
  gatewayFee         Decimal?
  netAmount          Decimal?

  buyerPlatformFee   Decimal  @default(0)
  buyerProcessingFee Decimal  @default(0)
  sellerPlatformFee  Decimal  @default(0)
  platformRevenue    Decimal  @default(0)

  heldAt             DateTime @default(now())
  updatedAt          DateTime @updatedAt
}
model SellerPayout {
  id            String   @id @default(cuid())
  orderId       String
  order         Order    @relation(fields: [orderId], references: [id])

  amount        Decimal
  currency      String   @default("ZAR")
  status        String   @default("PENDING")

  availableAt   DateTime
  batchId       String?
  externalRef   String?
  failureReason String?

  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  @@index([status, availableAt])
  @@index([batchId])
}
Then:
Create migration and run prisma generate.

Update all Prisma calls in later tasks to match the schema.

Task 2 — Add fee engine (single source of truth)
Create file: apps/api/src/services/fee-engine.ts
Paste this file exactly:

export type Gateway = "PAYFAST" | "OZOW";
export type Method = "CARD" | "EFT" | "UNKNOWN";

export interface FeePolicy {
  buyerPlatformPct: number;
  buyerPlatformMin: number;
  buyerProcessingMin: number;

  sellerTiers: Array<{ upTo?: number; pct: number; min: number }>;

  bufferPct: number;
  bufferFixed: number;
  vatPct: number;
}

export interface FeeCalcInput {
  baseAmount: number;
  currency: "ZAR";
  gateway: Gateway;
  method: Method;
  policy: FeePolicy;
}

export interface FeeCalcOutput {
  baseAmount: number;
  buyerPlatformFee: number;
  buyerProcessingFee: number;
  sellerPlatformFee: number;
  platformRevenue: number;
  grossAmount: number;
  sellerPayoutTarget: number;
  estimatedGatewayFee: number;
  estimatedNetToPlatform: number;
}

const round2 = (n: number) => Math.round(n * 100) / 100;
const max2 = (a: number, b: number) => (a > b ? a : b);

function estimatePayfastFeeInclVat(gross: number, method: Method, vatPct: number): number {
  const m = method === "UNKNOWN" ? "CARD" : method;
  const feeExVat = m === "EFT" ? Math.max(gross * 0.02, 2) : gross * 0.032 + 2;
  return feeExVat * (1 + vatPct);
}

function pickSellerTier(baseAmount: number, tiers: Array<{ upTo?: number; pct: number; min: number }>) {
  for (const t of tiers) {
    if (t.upTo == null) return t;
    if (baseAmount <= t.upTo) return t;
  }
  return tiers[tiers.length - 1];
}

export function defaultFeePolicy(): FeePolicy {
  return {
    buyerPlatformPct: 0.03,
    buyerPlatformMin: 10,
    buyerProcessingMin: 15,
    sellerTiers: [
      { upTo: 500, pct: 0.12, min: 15 },
      { upTo: 2000, pct: 0.10, min: 20 },
      { pct: 0.08, min: 30 },
    ],
    bufferPct: 0.002,
    bufferFixed: 1,
    vatPct: 0.15,
  };
}

export function calculateFees(input: FeeCalcInput): FeeCalcOutput {
  const { baseAmount, gateway, method, policy } = input;
  if (!Number.isFinite(baseAmount) || baseAmount <= 0) throw new Error("Invalid baseAmount");

  const buyerPlatformFee = round2(max2(baseAmount * policy.buyerPlatformPct, policy.buyerPlatformMin));

  const tier = pickSellerTier(baseAmount, policy.sellerTiers);
  const sellerPlatformFee = round2(max2(baseAmount * tier.pct, tier.min));

  const startProcessing = policy.buyerProcessingMin;
  const gross0 = baseAmount + buyerPlatformFee + startProcessing;

  const est0 = gateway === "PAYFAST"
    ? estimatePayfastFeeInclVat(gross0, method, policy.vatPct)
    : estimatePayfastFeeInclVat(gross0, method, policy.vatPct); // TODO: OZOW estimate

  const estBuffered = est0 + est0 * policy.bufferPct + policy.bufferFixed;

  const buyerProcessingFee = round2(max2(estBuffered, policy.buyerProcessingMin));

  const grossAmount = round2(baseAmount + buyerPlatformFee + buyerProcessingFee);

  const estimatedGatewayFee = gateway === "PAYFAST"
    ? round2(estimatePayfastFeeInclVat(grossAmount, method, policy.vatPct))
    : round2(estimatePayfastFeeInclVat(grossAmount, method, policy.vatPct)); // TODO: OZOW estimate

  const platformRevenue = round2(buyerPlatformFee + sellerPlatformFee);
  const sellerPayoutTarget = round2(baseAmount - sellerPlatformFee);
  const estimatedNetToPlatform = round2(grossAmount - estimatedGatewayFee);

  return {
    baseAmount: round2(baseAmount),
    buyerPlatformFee,
    buyerProcessingFee,
    sellerPlatformFee,
    platformRevenue,
    grossAmount,
    sellerPayoutTarget,
    estimatedGatewayFee,
    estimatedNetToPlatform,
  };
}
Task 3 — Add quote endpoint + rework order creation to store breakdown
File: apps/api/src/routes/order.routes.ts
3.1 Import fee engine at top
Add:

import { calculateFees, defaultFeePolicy, type Gateway, type Method } from '@/services/fee-engine.js';
3.2 Add quote endpoint
Add BEFORE router.post('/', ...):

router.post('/quote', authenticate, async (req, res, next) => {
  try {
    const { baseAmount, gateway = "PAYFAST", method = "CARD" } = req.body ?? {};
    const fees = calculateFees({
      baseAmount: Number(baseAmount),
      currency: "ZAR",
      gateway: gateway as Gateway,
      method: method as Method,
      policy: defaultFeePolicy(),
    });
    return res.json({ success: true, fees });
  } catch (err) {
    return next(err);
  }
});
3.3 Patch POST /api/v1/orders
Replace any calculateOrderFees(...) usage with:

const gateway = (req.body?.paymentGateway ?? "PAYFAST") as Gateway;
const method = (req.body?.paymentMethod ?? "CARD") as Method;

const fees = calculateFees({
  baseAmount: Number(baseAmount),
  currency: "ZAR",
  gateway,
  method,
  policy: defaultFeePolicy(),
});
In prisma.order.create, store:

buyerPlatformFee

buyerProcessingFee

sellerPlatformFee

platformRevenue

grossAmount

currency

gateway

gatewayMethod

status: 'PENDING_PAYMENT'

If you keep old columns temporarily, also map:

buyerFee = buyerPlatformFee

sellerFee = sellerPlatformFee

totalAmount = grossAmount

Task 4 — Charge buyer grossAmount during payment initiation
File: apps/api/src/routes/payment.routes.ts
Find:

const amount = Number(order.totalAmount);
Replace:

const amount = Number((order as any).grossAmount ?? (order as any).totalAmount);
Remove unused import:

calculateOrderFees from @zomieks/shared if present.

Task 5 — PayFast ITN: verify amount, ensure idempotency, record tx + escrow hold
File: apps/api/src/routes/webhook.routes.ts (handler for POST /payfast)
5.1 Verify amount_gross matches expected gross
Insert after loading order:

const expectedGross = Number((order as any).grossAmount ?? (order as any).totalAmount);
const receivedGross = Number(itnData.amount_gross);
if (Math.round(receivedGross * 100) !== Math.round(expectedGross * 100)) {
  return res.status(400).send('Amount mismatch');
}
5.2 Idempotency by pf_payment_id
Before creating transaction:

const existingTx = await prisma.transaction.findFirst({
  where: { gatewayReference: itnData.pf_payment_id },
});
if (existingTx) return res.status(200).send('OK');
5.3 Create Transaction with schema-aligned fields
Use:

const transaction = await prisma.transaction.create({
  data: {
    type: 'PAYMENT',
    status: 'COMPLETED',
    gateway: 'PAYFAST',
    gatewayReference: itnData.pf_payment_id,
    orderId: order.id,

    grossAmount: itnData.amount_gross,
    gatewayFee: itnData.amount_fee,
    netAmount: itnData.amount_net,
    currency: 'ZAR',

    buyerPlatformFee: (order as any).buyerPlatformFee ?? (order as any).buyerFee ?? 0,
    buyerProcessingFee: (order as any).buyerProcessingFee ?? 0,
    sellerPlatformFee: (order as any).sellerPlatformFee ?? (order as any).sellerFee ?? 0,
    platformRevenue: (order as any).platformRevenue ?? 0,

    gatewayResponse: itnData,
  },
});
5.4 Set order status to paid-held
Update:

await prisma.order.update({
  where: { id: order.id },
  data: { status: 'PAID_HELD' },
});
5.5 Upsert EscrowHold (unique by orderId)
await prisma.escrowHold.upsert({
  where: { orderId: order.id },
  update: {
    status: 'HELD',
    grossAmount: itnData.amount_gross,
    gatewayFee: itnData.amount_fee,
    netAmount: itnData.amount_net,
    buyerPlatformFee: (order as any).buyerPlatformFee ?? (order as any).buyerFee ?? 0,
    buyerProcessingFee: (order as any).buyerProcessingFee ?? 0,
    sellerPlatformFee: (order as any).sellerPlatformFee ?? (order as any).sellerFee ?? 0,
    platformRevenue: (order as any).platformRevenue ?? 0,
  },
  create: {
    orderId: order.id,
    status: 'HELD',
    grossAmount: itnData.amount_gross,
    gatewayFee: itnData.amount_fee,
    netAmount: itnData.amount_net,
    buyerPlatformFee: (order as any).buyerPlatformFee ?? (order as any).buyerFee ?? 0,
    buyerProcessingFee: (order as any).buyerProcessingFee ?? 0,
    sellerPlatformFee: (order as any).sellerPlatformFee ?? (order as any).sellerFee ?? 0,
    platformRevenue: (order as any).platformRevenue ?? 0,
  },
});
5.6 Fix scheduleEscrowRelease import
If scheduleEscrowRelease is imported but not implemented, remove it from imports OR implement it. Do not leave broken imports.

Task 6 — Ozow webhook: mirror PayFast behavior
File: apps/api/src/routes/webhook.routes.ts (handler for POST /ozow)
Implement:

load order

verify amount == expectedGross

idempotent by gatewayReference (ozow txn id)

create transaction + upsert escrowHold

set order status PAID_HELD

Task 7 — Release escrow: create SellerPayout with reserve delay
File: apps/api/src/services/escrow.service.ts
In releaseOrderEscrow(orderId):

payout amount = baseAmount - sellerPlatformFee

availableAt = now + 7 days

create SellerPayout PENDING

mark escrow RELEASED

mark order RELEASED

Paste-ready:

const reserveDays = 7;
const availableAt = new Date(Date.now() + reserveDays * 24 * 60 * 60 * 1000);

const sellerFee = Number((order as any).sellerPlatformFee ?? (order as any).sellerFee ?? 0);
const payoutAmount = Number(order.baseAmount) - sellerFee;

await tx.sellerPayout.create({
  data: {
    orderId: order.id,
    amount: payoutAmount,
    currency: (order as any).currency ?? 'ZAR',
    status: 'PENDING',
    availableAt,
  }
});

await tx.escrowHold.update({ where: { orderId: order.id }, data: { status: 'RELEASED' } });
await tx.order.update({ where: { id: order.id }, data: { status: 'RELEASED' } });
Task 8 — Manual refund endpoint (MVP)
File: apps/api/src/routes/order.routes.ts
Add:
POST /api/v1/orders/:id/refund

Rules:

only allowed before release

create REFUND transaction (manual)

set escrow REFUNDED

set order REFUNDED

block payouts

(Implement with the snippet from earlier if needed.)

Task 9 — Batch payout processing using existing scheduler hook
There is already schedulePayoutProcessing imported and called in apps/api/src/index.ts.

File: apps/api/src/services/payout.service.ts
Ensure the job:

selects payouts: status='PENDING' AND availableAt <= now AND amount >= 100

sets batchId and status='PROCESSING'

outputs export payload (JSON/CSV)

later confirm endpoint can set PAID with externalRef

Task 10 — Add admin payout confirm endpoint (minimal)
Create: apps/api/src/routes/admin.payouts.routes.ts
Mount in apps/api/src/index.ts:

import adminPayoutRoutes from './routes/admin.payouts.routes.js';
app.use('/api/v1/admin/payouts', adminPayoutRoutes);
Add confirm route:

POST /api/v1/admin/payouts/batches/:batchId/confirm sets payouts to PAID

REFACTOR DECISION TABLE (use while grepping)
If you find buyerFee:
If it’s display/returning buyer marketplace fee → rename to buyerPlatformFee and ALSO return buyerProcessingFee.

If it’s used in buyer totals → buyer pays buyerPlatformFee + buyerProcessingFee.

If it’s DB field access → use safe fallback: (order.buyerPlatformFee ?? order.buyerFee ?? 0).

If you find sellerFee:
It means seller commission → rename to sellerPlatformFee.

Seller payout always: baseAmount - sellerPlatformFee (never gross).

If you find totalAmount:
If used as amount to gateway or buyer total → replace with grossAmount.

Safe transitional: grossAmount ?? totalAmount.

In ITN/callback:
MUST verify amount_gross matches expected gross

MUST enforce idempotency by gateway reference id

MUST store gross/fee/net

Grep order (do these commands and patch each hit)
grep -R "calculateOrderFees" -n apps/api/src

grep -R "\.buyerFee\b\|buyerFee:" -n apps/api/src

grep -R "\.sellerFee\b\|sellerFee:" -n apps/api/src

grep -R "\.totalAmount\b\|totalAmount:" -n apps/api/src

grep -R "amount_gross\|amount_fee\|amount_net\|pf_payment_id" -n apps/api/src

grep -R "SellerPayout\|payoutAmount\|sellerPayout" -n apps/api/src

Definition of Done (must demonstrate)
POST /api/v1/orders/quote returns fee breakdown and grossAmount.

POST /api/v1/orders stores breakdown and status PENDING_PAYMENT.

GET /api/v1/payments/initiate charges grossAmount.

POST /webhooks/payfast verifies gross, idempotent, creates Transaction + EscrowHold, sets PAID_HELD.

Release creates SellerPayout PENDING with reserve delay.

Payout job batches eligible payouts into PROCESSING.

Admin confirm marks payouts PAID.

Refund before release marks REFUNDED and blocks payout.

